{
  "_args": [
    [
      {
        "raw": "passport-jwt@*",
        "scope": null,
        "escapedName": "passport-jwt",
        "name": "passport-jwt",
        "rawSpec": "*",
        "spec": "*",
        "type": "range"
      },
      "E:\\codes\\Web\\CV-manager-app"
    ]
  ],
  "_from": "passport-jwt@*",
  "_id": "passport-jwt@2.2.1",
  "_inCache": true,
  "_location": "/passport-jwt",
  "_nodeVersion": "6.7.0",
  "_npmOperationalInternal": {
    "host": "packages-12-west.internal.npmjs.com",
    "tmp": "tmp/passport-jwt-2.2.1.tgz_1478748434609_0.21114882663823664"
  },
  "_npmUser": {
    "name": "themikenicholson",
    "email": "themikenicholson@gmail.com"
  },
  "_npmVersion": "3.10.7",
  "_phantomChildren": {},
  "_requested": {
    "raw": "passport-jwt@*",
    "scope": null,
    "escapedName": "passport-jwt",
    "name": "passport-jwt",
    "rawSpec": "*",
    "spec": "*",
    "type": "range"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/passport-jwt/-/passport-jwt-2.2.1.tgz",
  "_shasum": "0e004c94071319d673d9d9bcfd1574a868011527",
  "_shrinkwrap": null,
  "_spec": "passport-jwt@*",
  "_where": "E:\\codes\\Web\\CV-manager-app",
  "author": {
    "name": "Mike Nicholson"
  },
  "bugs": {
    "url": "https://github.com/themikenicholson/passport-jwt/issues"
  },
  "dependencies": {
    "jsonwebtoken": "^7.0.0",
    "passport-strategy": "^1.0.0"
  },
  "description": "Passport authentication strategy using JSON Web Tokens",
  "devDependencies": {
    "chai": "^3.0.0",
    "chai-passport-strategy": "^1.0.0",
    "istanbul": "^0.4.5",
    "mocha": "^3.0.0",
    "sinon": "^1.0.0"
  },
  "directories": {},
  "dist": {
    "shasum": "0e004c94071319d673d9d9bcfd1574a868011527",
    "tarball": "https://registry.npmjs.org/passport-jwt/-/passport-jwt-2.2.1.tgz"
  },
  "gitHead": "6ff2a4a63ff6e3475fc0fb28207221e9ca4d3d48",
  "homepage": "https://github.com/themikenicholson/passport-jwt",
  "keywords": [
    "Passport",
    "Strategy",
    "JSON",
    "Web",
    "Token",
    "JWT"
  ],
  "license": "MIT",
  "main": "./lib",
  "maintainers": [
    {
      "name": "themikenicholson",
      "email": "themikenicholson@gmail.com"
    }
  ],
  "name": "passport-jwt",
  "optionalDependencies": {},
  "readme": "\n\n# passport-jwt\n\n[![Build Status](https://travis-ci.org/themikenicholson/passport-jwt.svg?branch=master)](https://travis-ci.org/themikenicholson/passport-jwt)\n\nA [Passport](http://passportjs.org/) strategy for authenticating with a\n[JSON Web Token](http://jwt.io).\n\nThis module lets you authenticate endpoints using a JSON web token. It is\nintended to be used to secure RESTful endpoints without sessions.\n\n## Install\n\n    npm install passport-jwt\n\n## Usage\n\n### Configure Strategy\n\nThe JWT authentication strategy is constructed as follows:\n\n    new JwtStrategy(options, verify)\n\n`options` is an object literal containing options to control how the token is\nextracted from the request or verified.\n\n* `secretOrKey` is a REQUIRED string or buffer containing the secret\n  (symmetric) or PEM-encoded public key (asymmetric) for verifying the token's\n  signature.\n\n* `jwtFromRequest` (REQUIRED) Function that accepts a request as the only\n  parameter and returns either the JWT as a string or *null*. See \n  [Extracting the JWT from the request](#extracting-the-jwt-from-the-request) for\n  more details.\n* `issuer`: If defined the token issuer (iss) will be verified against this\n  value.\n* `audience`: If defined, the token audience (aud) will be verified against\n  this value.\n* `algorithms`: List of strings with the names of the allowed algorithms. For instance, [\"HS256\", \"HS384\"].\n* `ignoreExpiration`: if true do not validate the expiration of the token.\n* `passReqToCallback`: If true the request will be passed to the verify\n  callback. i.e. verify(request, jwt_payload, done_callback).\n\n`verify` is a function with the parameters `verify(jwt_payload, done)`\n\n* `jwt_payload` is an object literal containing the decoded JWT payload.\n* `done` is a passport error first callback accepting arguments\n  done(error, user, info)\n\nAn example configuration which reads the JWT from the http\nAuthorization header with the scheme 'JWT':\n\n```js\nvar JwtStrategy = require('passport-jwt').Strategy,\n    ExtractJwt = require('passport-jwt').ExtractJwt;\nvar opts = {}\nopts.jwtFromRequest = ExtractJwt.fromAuthHeader();\nopts.secretOrKey = 'secret';\nopts.issuer = \"accounts.examplesoft.com\";\nopts.audience = \"yoursite.net\";\npassport.use(new JwtStrategy(opts, function(jwt_payload, done) {\n    User.findOne({id: jwt_payload.sub}, function(err, user) {\n        if (err) {\n            return done(err, false);\n        }\n        if (user) {\n            done(null, user);\n        } else {\n            done(null, false);\n            // or you could create a new account\n        }\n    });\n}));\n```\n\n### Extracting the JWT from the request\n\nThere are a number of ways the JWT may be included in a request.  In order to remain as flexible as\npossible the JWT is parsed from the request by a user-supplied callback passed in as the\n`jwtFromRequest` parameter.  This callback, from now on referred to as an extractor,\naccepts a request object as an argument and returns the encoded JWT string or *null*.\n\n#### Included extractors \n\nA number of extractor factory functions are provided in passport-jwt.ExtractJwt. These factory\nfunctions return a new extractor configured with the given parameters.\n\n* ```fromHeader(header_name)``` creates a new extractor that looks for the JWT in the given http\n  header\n* ```fromBodyField(field_name)``` creates a new extractor that looks for the JWT in the given body\n  field.  You must have a body parser configured in order to use this method.\n* ```fromUrlQueryParameter(param_name)``` creates a new extractor that looks for the JWT in the given\n  URL query parameter.\n* ```fromAuthHeaderWithScheme(auth_scheme)``` creates a new extractor that looks for the JWT in the\n  authorization header, expecting the scheme to match auth_scheme.\n* ```fromAuthHeader()``` creates a new extractor that looks for the JWT in the authorization header\n  with the scheme 'JWT'\n* ```fromExtractors([array of extractor functions])``` creates a new extractor using an array of\n  extractors provided. Each extractor is attempted in order until one returns a token.\n\n### Writing a custom extractor function\n\nIf the supplied extractors don't meet your needs you can easily provide your own callback. For\nexample, if you are using the cookie-parser middleware and want to extract the JWT in a cookie \nyou could use the following function as the argument to the jwtFromRequest option:\n\n```\nvar cookieExtractor = function(req) {\n    var token = null;\n    if (req && req.cookies)\n    {\n        token = req.cookies['jwt'];\n    }\n    return token;\n};\n```\n\n### Authenticate requests\n\nUse `passport.authenticate()` specifying `'JWT'` as the strategy.\n\n```js\napp.post('/profile', passport.authenticate('jwt', { session: false}),\n    function(req, res) {\n        res.send(req.user.profile);\n    }\n);\n```\n\n### Include the JWT in requests\n\nThe strategy will first check the request for the standard *Authorization*\nheader. If this header is present and the scheme matches `options.authScheme`\nor 'JWT' if no auth scheme was specified then the token will be retrieved from\nit. e.g.\n\n    Authorization: JWT JSON_WEB_TOKEN_STRING.....\n\nIf the authorization header with the expected scheme is not found, the request\nbody will be checked for a field matching either `options.tokenBodyField` or\n`auth_token` if the option was not specified.\n\nFinally, the URL query parameters will be checked for a field matching either\n`options.tokenQueryParameterName` or `auth_token` if the option was not\nspecified.\n\n## Migrating from version 1.x.x to 2.x.x\n\nThe v2 API is not backwards compatible with v1, specifically with regards to the introduction\nof the concept of JWT extractor functions.  If you require the legacy behavior in v1 you can use\nthe extractor function ```versionOneCompatibility(options)```\n\n*options* is an object with any of the three custom JWT extraction options present in the v1\nconstructor:\n* `tokenBodyField`: Field in a request body to search for the JWT.\n  Default is auth_token.\n* `tokenQueryParameterName`: Query parameter name containing the token.\n  Default is auth_token.\n* `authScheme`: Expected authorization scheme if token is submitted through\n  the HTTP Authorization header. Defaults to JWT\n\nIf in v1 you constructed the strategy like this:\n\n```js\nvar JwtStrategy = require('passport-jwt').Strategy;\nvar opts = {}\nopts.tokenBodyField = \"MY_CUSTOM_BODY_FIELD\";\nopts.secretOrKey = 'secret';\nopts.issuer = \"accounts.examplesoft.com\";\nopts.audience = \"yoursite.net\";\npassport.use(new JwtStrategy(opts, verifyFunction));\n```\n\nIdentical behavior can be achieved under v2 with the versionOneCompatibility extractor:\n\n```js\nvar JwtStrategy = require('passport-jwt').Strategy,\n    ExtractJwt = require('passport-jwt').ExtractJwt;\nvar opts = {}\nopts.jwtFromRequest = ExtractJwt.versionOneCompatibility({ tokenBodyField = \"MY_CUSTOM_BODY_FIELD\" });\nopts.opts.secretOrKey = 'secret';\nopts.issuer = \"accounts.examplesoft.com\";\nopts.audience = \"yoursite.net\";\npassport.use(new JwtStrategy(opts, verifyFunction));\n```\n\n\n## Tests\n\n    npm install\n    npm test\n\nTo generate test-coverage reports:\n\n    npm install -g istanbul\n    npm run-script testcov\n    istanbul report\n\n## License\n\nThe [MIT License](http://opensource.org/licenses/MIT)\n\nCopyright (c) 2015 Mike Nicholson\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/themikenicholson/passport-jwt.git"
  },
  "scripts": {
    "test": "mocha --reporter spec --require test/bootstrap test/*test.js",
    "testcov": "istanbul cover node_modules/mocha/bin/_mocha -- --reporter spec --require test/bootstrap test/*test.js"
  },
  "version": "2.2.1"
}
